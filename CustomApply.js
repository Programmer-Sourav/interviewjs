
// The only change in code is in the 1st line where we take `args` as it is and not in the rest operator format
// `...args` as in the call() method
Function.prototype.apply = function myApply(thisArg, args){
// Get the actual function that needs to be invoked and on
//which we need to set the "this" context
    const fn = this;
// We know the fact that the "this" context for a method will
//be set based on the object which calls it
// `thisArg` will be our object or context we need to set
    const context = Object(thisArg);

// Note: We wrap `thisArg` in an Object constructor, to
//handle primitive values as well like null, undefined, number,
//string, which returns their wrapper objects
// Generate a unique key using `Symbol()` to avoid object
//property conflicts
    const key = Symbol();
    // Set the invoking function `fn` as a value for the unique
//`key` as a property on the object `context`
    context[key] = fn;
    // Now all we need to do is invoke `fn` via `context` object
//and pass the additional args as well
    const result = context[key](...args)
    // Finally once we're done calling the function `fn`
// We delete the property from the `context` obj to avoid
//memory leaks
    delete context[key];
// Return away the result generated by invoking the function
//`fn`
    return result;
}